<!DOCTYPE html>
<!--
	Directive by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
  <head>
    <title>The Java-Engine</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, user-scalable=no"
    />
    <link rel="stylesheet" href="../assets/css/main.css" />
  </head>
  <body class="is-preload">
    <!-- Header -->
    <div id="header">
      <span class="logo icon fa-paper-plane"></span>
      <h1>The Java-Engine</h1>
    </div>

    <!-- Main -->
    	<div class="box container">
					<header>
						<h2>"Dann schauen wir dem Ding mal unter die Haube..."</h2>
					</header>
					<section>
							<p> Natürlich ist es spannend, sich einmal genauer anzuschauen, was bei der Ausführung eines Codes eigentlich passiert. Die Java-Engine funktioniert wie folgt: 
            </p>
					</section>
					<section>
						<header>
							<h3>Write once Run anywhere</h3>
						</header>
						<blockquote> Java ist WORA (Write once Run anywhere). Das bedeutet, der Java-Quellcode ist auf allen Betriebssystemen lauffähig. Der vom Javac-Compiler generierte Bytecode (.class) kann auf jedem Betriebssystem ausgeführt werden.</blockquote>
					</section>
					<section>
            <header>
							<h3>Jetzt gehts los...</h3>
						</header>
            <hr />
            <p> 
            Sprechen wir erst mal davon, was der Prozessor des Computers für Fähigkeiten beherrscht. Der Prozessor kennt nämlich nur ganz grundlegende Operationen wie zum Beispiel die Grundrechenarten und das Lesen sowie Schreiben im Arbeitsspeicher. 
            
            Alle Programme
die man auf dem Computer ausführt bestehen ausschließlich aus tausenden von solchen
grundlegenden Operationen. Diese werden in Maschinencode gespeichert, wobei ein solcher Maschinencode einfach die Hintereinanderreihung von Nummern ist und jede Nummer für eine Operation steht. 
<br> <br>
Die Befehle einer Programmiersprache sind
so gebaut, dass man durch ihre Kombination aufgabenorientiert dem Computer Anweisungen geben kann und nicht mehr gezwungen ist alles in Grundrechenarten
oder Speicherzugriffe herunter zu brechen. Zu einer Datei, die Anweisungen in einer Hochsprache enthält, sagt man Quelltext (Source Code). Allerdings ist ein solcher Quelltext nicht mehr direkt
vom Prozessor ausführbar, denn ein Befehl aus der Hochsprache steht häufig für eine Aneinanderreihung von vielen Maschinenbefehlen, oft in Abhängigkeit zu vorhergehenden
Befehlen der Hochsprache. Aus diesem Grunde muss man ein Übersetzungsprogramm –
der sogenannte Compiler – verwenden, um aus dem in einer Hochsprache geschriebenen
Quelltext wieder Maschinencode zu erzeugen.

Einige der Vorteile von Java als Programmiersprache sind folgende:
<ul class="default">
<li>Objektorientierte Sprache - Programme werden in Modulen erstellt, was bedeutet, dass wir diese Programme wiederverwenden können.</li>
<li>Plattformunabhängigkeit - Das Programm kann mit Hilfe von JVM (Java Virtual Machine) auf jeder anderen Maschine ausgeführt werden.</li>
<li>Sicher - Java hat einen Sicherheitsmanager, der den Zugriff auf Klassen definiert.</li>
<li>Multithreading - kann mehrere Aufgaben gleichzeitig ausführen.</li>
<li>Speicher - Java verwendet Heap und Stack für die Speicherzuweisung, was uns hilft, Daten einfach zu speichern und abzurufen.</li>
</ul>
            </p>
						<header>
							<h3>JDK, JVM, JRE? </h3>
						</header>
            <hr />
            <div style="text-align: center;">
							<h3>Im Überblick</h3>
              <hr>
						<img src="../images/JDK.png" style="width: 60%" />
          </div>
						<p> 
              <strong>Java-Development-Kit (JDK) : Das Java-Entwicklungskit: </strong>
              <br/>
              Ein JDK ist eine Softwareentwicklungsumgebung, die zum Erstellen von Applets und Java-Anwendungen verwendet wird.
              <br/><br/>
              <strong>Java Runtime Environment-Software(JRE + Compiler + Debugger JRE): </strong>
              <br/>Die Java Runtime Environment-Software wurde entwickelt, um andere Software auszuführen. So benötigen wir die JRE auch um Java auszuführen. Die JRE enthält Klassenbibliotheken, Ladeklassen und andere Komponenten zum Ausführen von Applets / Java-Anwendungen. Dazu gehört auch die JVM.
              <br/><br/>
              <strong>Java Virtual Machine (JVM):</strong>
              <br/>
              Die virtuelle Maschine ist ein Teil der Java-Laufzeitumgebung(JRE), auf der der Java-Bytecode ausgeführt wird. Sie macht Java portabel. Die JVM kommt mit einem JIT (Just-In-Time)-Compiler, der Java-Quellcode in Low-Level-Maschinensprache konvertiert. Der Bytecode ist verständlich, sofern eine JVM auf einem Betriebssystem installiert ist.
             </p>
					</section>
				
          <section>
						<header>
							<h3>Die Java-JIT-Kompilierung</h3>
						</header>
            <hr />
						<p> "Die Just-In-Time (JIT)-Kompilierung ist auch als dynamische Kompilierung bekannt."
            <br/> <br/>
            Was läuft also "under the hood" bei der Kompilierung?
            <br/><br/>
            Das Programm wird während der Laufzeit in nativen Code kompiliert, um die Leistung zu verbessern. Bei der JIT-Kompilierung wird bytecode(.class) übersetzt in Maschinencodeanweisungen von laufenden Maschinen.
            <br/><br/>
            Der resultierende Maschinencode ist für die "Central Processing Unit(CPU/Hauptprozessor)-Architektur" der laufenden Maschine optimiert.
            Die Kompilierung erfolgt zur Laufzeit des Programms (im Gegensatz zur Ausführung).
            <br/><br/>
            Da die Kompilierung zur Laufzeit erfolgt, hat der JIT-Compiler Zugriff auf dynamische Laufzeitinformationen, wodurch er bessere Optimierungen vornehmen kann. Dabei soll die Effizienz der Ausführung von Maschinencode, die Ineffizienz der Neukompilierung von Programmen bei jeder Ausführung überwinden.
            <br/><br/>
            <strong>Optimierungen</strong><br/>
            Die JVM führt den Bytecode aus und zählt, wie oft die Funktion ausgeführt wird. Wenn die Anzahl das vordefinierte Limit überschreitet, wird via JIT Code in Maschinensprache kompiliert, der direkt vom Prozessor ausgeführt werden kann. Beim nächsten Mal wird die Funktion berechnet, der kompilierte Code wird im Gegensatz zur normalen Interpretation erneut ausgeführt. Das führt zu einer schnelleren Ausführung.
            </p>
					</section>
					<section>
						<header>
							<h3> Der Heap- und Stack-Speicher</h3>
						</header>
            <hr />
					<p>
             Um eine Anwendung optimal auszuführen, teilt die JVM den Speicher in Stack & Heap-Speicher auf. Stack und Heap sind Teile des Arbeitsspeichers und beide sehr unterschiedlich strukturiert. Du kannst dir den Heap tatsächlich als Haufen vorstellen, auf dem jede Menge Platz ist. Während der Stack von der Größe her stark begrenzt ist, kann der Heap anwachsen bis die Speichergrenze auf Prozessebene erreicht ist.
              <br/><br/>
              Dafür ist der Heap aber intern nicht so einfach zu verwalten, was ihn langsamer als den strukturierten und effizienten Stack macht. Auf dem Heap angelegter Speicher muss auch explizit wieder freigegeben werden (z.B. durch den Garbage Collector).
              <br/><br/>
              Um auf den Heap zuzugreifen, werden Referenzen verwendet also sozusagen Zeiger auf dem Stack, die auf Objekte verweisen, die auf dem Heap liegen. Neue Objekte werden immer im Heap-Space erstellt und die Referenzen auf diese Objekte werden im Stack-Speicher abgelegt.
              Die Referenzen/Zeiger auf dem Stack, beinhalten anders beschrieben die Speicheradresse des Objektes.
              <br/><br/>
              Da auf dem Heap angelegte Objekte nicht auf den lokalen Sichtbarkeitsbereich beschränkt sind, kann global darauf zugegriffen werden (sofern ein Zeiger oder eine Referenz vorhanden ist).

              <br/><br/>
              
              <strong>Heap</strong>
              <ul class="default">
              <li>Führt tatsächliche Objekte</li>
              <li>Hat eine dynamische Speicherzuweisung für Java-Objekte und JRE-Klassen zur Laufzeit</li> 
              <li>Ist wie ein String-Pool</li>
              <li>Ist nicht Thread-sicher: muss durch ordnungsgemäß synchronisierenden Code geschützt werden</li>
             <li>Wird beim Start von JVM erstellt und kann während der Ausführung der Anwendung größer/kleiner werden.</li>
             <li>Wenn der Heap voll ist, wird der Garbage Collector eingesetzt. So werden nicht mehr benötigte Gegenstände geräumt und so Platz für neue Objekte geschaffen.</li>
              <li>Objekte können von überall in der Anwendung aufgerufen werden</li>
              
            </ul>
            <strong>Der Heap zerlegt in 3 Teile:</strong>
              <br/>
              <strong>Young Generation:</strong> Alle neuen Objekte werden hierhin zugewiesen.
              <br/>
              <strong>Old / Tenured Generation:</strong> Für Objekte, die in der Young Gen gespeichert wurden, und einen gewissen Schwellenwert(vorab festgelegt) des Lagerns/Alterns überschritten haben. Sobald die Schwelle erreicht ist, werden diese Objekt in die Old Gen verschoben.
              <br/>
              <strong>Permanent Generation:</strong> JVM-Metadaten für Laufzeitklassen und Anwendungsmethoden.
              
              <br/><br/>

              <strong>Stack</strong>
              <ul class="default">
                <li>Der Stack wird für die Ausführung eines Threads verwendet</li>
              <li>Führt primitive Werte, die für eine Methode spezifisch sind</li>
              <li>Verweise aus Methoden auf Objekte, die sich im Heap befinden</li>
             <li> thread-safe : jeder Thread wird in einem eigenen Stack betrieben 
             </li>
           <li>in LIFO-Reihenfolge ("last in - first out") referenziert</li>
             <li> Wenn eine neue Methode aufgerufen wird, wird ein neuer Block oben auf dem Stapel erstellt, der für diese Methode spezifische Werte enthält (z. B. primitive Variablen und Verweise auf Objekte).</li>
             <li> Methode beendet die Ausführung -> entsprechender Stack wird geleert, Prozess geht zurück zum Aufruf der Methode. Nun ist wieder Speicherplatz für die nächste Methode verfügbar</li>
            </ul>
            <div style="text-align: center;">
							<h3>Heap & Stack</h3>
              <hr>
						<img src="../images/heap.png" style="width: 60%" />
          </div>
              <ol class="default"> <strong>Zusammenfassung</strong>
              <li>Programm wird ausgeführt und Laufzeitklassen in Heaps-Space geladen</li>
              <li>main()-Methode wird in Zeile 1 gefunden, erstellt zur Laufzeit den Stack-Speicher, der vom Thread der main()-Methode verwendet werden soll. </li>
              <li>Immer wenn ein neues Objekt erstellt wird, kommt der Heap-Speicher zum Einsatz</li>
              <li>Der Stack-Speicher enthält die Referenz für das neue Objekt.</li>
              <li>Wenn eine neue Methode aufgerufen wird, wird ein neuer Block auf dem Stack erstellt (LIFO).</li>
              <li>Eine String-Referenz im Stack-Speicher, die auf den String-Pool im Heap-Space verweist.</li>
                <li>Wenn die Methode (foo()) beendet wird, wird der Stack wieder frei (der für die Funktion erstellte Stack-Speicher wird zerstört)</li>
                <li>Geht den nächsten Schritt im nächsten Programm (von oben nach unten in der main())</li>
						</ol>
          </p>
				</section>
					
          <footer class="major container medium videoWrapper">
            <h3>Java-Engine</h3>
            <img src="../images/matrix.gif"/ >
          </footer>
    </div>

    <!-- Footer -->
    <div id="footer">
      <div class="container medium">
        <header class="major last">
          <h2>Questions or comments?</h2>
        </header>

        <p>
          Einfach eine <a href="https://www.ninabraunger.de/#contact">Mail</a> schreiben.<br />
        </p>

        <ul class="copyright">
          <li>&copy; 2021 Nina Braunger</li>
          <li>
            <a href="https://www.ninabraunger.de/impressum.html">Impressum</a>
          </li>
          <li>
            <a href="https://www.ninabraunger.de/datenschutz.html"
              >Datenschutz</a
            >
          </li>
          <li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
          <br />
          <br />

          <li>
            Structure of site is released for free under the
            <a href="http://html5up.net/license">Creative Commons license</a>.
          </li>
        </ul>
      </div>
    </div>

    <!-- Scripts -->
    <!-- Scripts -->
    <script src="../assets/js/jquery.min.js"></script>
    <script src="../assets/js/browser.min.js"></script>
    <script src="../assets/js/breakpoints.min.js"></script>
    <script src="../assets/js/util.js"></script>
    <script src="../assets/js/main.js"></script>
  </body>
</html>