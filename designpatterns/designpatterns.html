<!DOCTYPE html>
<!--
	Directive by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
  <head>
    <title>Design Patterns</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, user-scalable=no"
    />
    <link rel="stylesheet" href="../assets/css/main.css" />
  </head>
  <body class="is-preload">
    <!-- Header -->
    <div id="header">
      <span class="logo icon fa-paper-plane"></span>
      <h1>Design Patterns</h1>
    </div>

    <!-- Main -->
    
    <div class="box container">
      <header>
        <h2>Design Patterns - Elegante Lösungen für sich wiederholende Probleme</h2>
      </header>
      <section>
         <p>
          Design Patterns, kann man als die Kunst 
          des Designens von objekt-orientierter Software bezeichnen. Die folgenden Design Patterns/ Techniken stammen aus dem Buch <a href="https://github.com/amilajack/reading/blob/master/Design/GOF%20Design%20Patterns.pdf">"Design Patterns"</a> der Gang of Four.
          <br><br>
          <hr>
          <h3>The SOLID-Principles</h3>
          Die Design-Patterns sind Techniken aus der objektorientierten Programmierung und folgen dementsprechend folgenden Prinzipien.
          <hr>
          <strong>Single-Responsibility-Prinzip:</strong><br>
          Das Single-Responsibility-Prinzip besagt, dass jede Klasse nur eine Aufgabe haben sollte.
          Eine Klasse sollte einen und nur einen Grund haben, sich zu ändern. Der Grund für dieses Prinzip ist die Trennung von Verantwortlichkeiten oder Verhaltensweisen, damit Debugging und Refactoring keine Probleme für andere Teile eines Projekts verursachen.
          <br><br>

          <strong>Open-closed-Principle:</strong><br>
          Unsere Klassen sollen offen gegenüber Erweiterungen sein aber geschlossen für Modifikationen. 
          <br><br>

          <strong>Liskov-substitution-Principle:</strong><br>
          Das Liskov-Substitutionsprinzip besagt, dass bei einer Vererbung eine Elternklasse problemlos durch ihre Kindklasse ersetzt werden kann.          
          Dies liegt daran, dass die untergeordnete Klasse bei der Vererbung in der Lage sein sollte, alles zu tun, was die übergeordnete Klasse kann, und die gleichen oder sogar verbesserte Ergebnisse liefern.
          <br><br>

          <strong>Interface Segregation Principle: (keyword: implements)</strong><br>
          Unter dem Prinzip der Schnittstellentrennung versteht man, dass ein Client niemals gezwungen werden sollte, eine Schnittstelle zu implementieren, die er nicht verwendet, oder dass Clients nicht gezwungen werden sollten, sich auf Methoden zu verlassen, die sie nicht verwenden. Das Ziel dieses Prinzips ist es, unnötigen Code aus Klassen, um unerwartete Fehler zu reduzieren, wenn die Klasse keine Aktion ausführen kann. Wir teilen Aktionen in kleinere Sets auf, damit eine Klasse nur die Aktionen ausführt, die sie benötigt.
          <br><br>

          <strong>Dependency Inversion Principle:</strong><br>
          Das Dependency Inversion Principle besagt, dass Entitäten von Abstraktionen abhängen müssen, nicht von Konkretionen. High-Level-Module(Klassen, die ein Tool/ eine Library implementieren) sollten nicht von Low-Level-Modulen (die Tools oder Librarys, die zum Ausführen einer Aktion benötigt werden) abhängen. Beides sollte von der Abstraktion abhängen. Das Prinzip ermöglicht die Entkopplung. Dies hilft uns, Abhängigkeiten zu reduzieren und in Zukunft eine einfachere Implementierung anderer Tools zu ermöglichen.
          <br><br>
          <hr>
          <h2>Principles of Object-Oriented-Programming:</h2>
          <strong>Inheritance (Keyword: extend):</strong>
          <br>       
          Wenn mehrere Klassen gemeinsame Attribute (variablen) und Verhalten (methods) haben, werden diese gemeinsamen Teile extrahiert und in einer öffentlichen Klasse definiert. Andere Klassen und Klassen können mit dieser öffentlichen Klasse eine Vererbungsbeziehung eingehen, so dass der öffentliche Teil nicht in mehreren Klassen neu definiert werden muss! Diese gemeinsame Klasse ist die übergeordnete Klasse, die auch als Parent/Base/Superclass bezeichnet wird, und die anderen Klassen sind die Unterklassen(Childs/Subclasses). Unterklassen können direkt auf nicht-private Variablen des Parents zugreifen.
          <br> 
          <br> 
          <strong>Polymorphism:</strong><br>
          Polymorphismus (viele Formen) ist die Implementierung eines Objekts mit verschiedenen Manifestationen. Ein Beispiel für Polymorphismus: Dieselbe Taste (z.B. "ENTER") kann in verschiedenen Applikationen, unterschiedliche Aktionen auslösen ("Zeilenvorschub", "Senden", "Öffnen") Das Drücken der "ENTER"-Taste spielt in verschiedenen Anwendungen eine andere Rolle. Polymorphism hilft bei der Skalierbarkeit, Flexibilität und Vereinfachung von Applikationen.  
          Polymorphism kann als Schnittstelle arbeiten und unterstützt darin die
          Kopplung zwischen Klassen aufzuheben.
          <br> 
          <br> 
          <strong>Encapsulation:</strong><br>
          Wir fassen die Objekte zusammen, die die gleichen Eigenschaften haben oder zur gleichen Klasse gehören, und verpacken Sie gut. Das bedeutet wir versuchen Coupling zu vermeiden. <br> 
          <br> 
          <strong>Coupling:</strong><br>
          Unter Coupling versteht man den Grad der gegenseitigen Abhängigkeit zwischen Klassen/Modulen. Die Kopplung ist ein Maß dafür, wie zwei oder mehr Komponenten voneinander abhängen. Wenn eine Ihrer Komponenten nicht mehr funktioniert, wenn die andere Komponente ausgefallen ist, sind sie fest gekoppelt. Rückblickend gilt: Je weniger diese Komponenten voneinander abhängig sind, desto lockerer sind sie gekoppelt. Ein starkes Coupling sollte im Sinne der objektorientierten Programmierung vermieden werden.  Idealerweise möchten wir, dass unsere Komponenten zu 100 % unabhängig sind.
        </p>
      </section>
      <header>
        <hr>
      <h3>Unified Modeling Language (UML)</h3>
      <hr>
    <p> Als Grundlage für Design Patterns, ist es von Vorteil die UML zu kennen. </p>
    <iframe src="https://www.youtube.com/embed/ws_KI4Wun4I" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
     </header>
  <a href="https://www.javatpoint.com/design-patterns-in-java">Hier</a> ein super Link. Und
  <a href="https://www.tutorialspoint.com/design_pattern/">hier</a> noch einer.
  
 <!-- https://dev.to/awwsmm/design-patterns-in-java-58na -->
        <section>
          <header>
            <br>
            <br>
            <hr />
            <h1>DESIGN PATTERNS</h1>
            <hr />
       
            <h3>/////////////Behavioural Design Patterns/////////////</h3>
            <p>Hier geht es um die Interaktion und Kommunikation zwischen den Objekten</p>
          </header>
        </section>
            
        <div class="accordion">
          <div class="accordion-item">
          <h3 class="accordion-title"> Memento Pattern </h3>
          <p class="accordion-answer">
           
            Die Idee dahinter: Wir wollen eine systematische Möglichkeit haben, eine Momentaufnahme des internen Zustands eines bestimmten Objekts zu speichern, ohne diesen Zustand offenzulegen, um sie später wiederherstellen zu können.
            <br>
            Mit dem Memento-Pattern erfassen und externalisieren  wir das Innere eines Objekts, ohne die Hülle zu verletzen.
            Damit kann das Objekt später in diesem Zustand wiederhergestellt werden. Zum Beispiel für den Undo/Redo-Mechanismus eines Text-Editors oder Taschenrechners. Oder für einen Snapshot eines Benutzerprofils, das nach dem Abbruch durch den User wiederhergestellt werden soll.
            <br><br>
            <strong>Originator</strong>:<br>
              - erstellt ein Memento, um den internen Zustand zu              speichern<br>
              - verwendet Mementos, um seinen Zustand               wiederherzustellen.<br><br>
              <strong>Memento</strong>:<br>
              - speichert einen unveränderlichen Snapshot des internen Zustands vom Originator<br>
              - kann nur vom Originator abgerufen werden<br><br>
              <strong>CareTaker</strong>:<br>
              - speichert Mementos<br>
              - bearbeitet oder liest nie Mementos.
          </p>
          <div class="img-wrapper">
          <img class="design-pattern" src="../images/mementopattern.png ">
        </div>
      </div>

        <div class="accordion-item">
          <h3 class="accordion-title"> State Pattern </h3>
          <p class="accordion-answer">
           
            Durch das State Pattern ändert sich das Verhalten einer Klasse basierend auf ihrem Zustand. Im State Pattern erstellen wir Objekte, die verschiedene Zustände darstellen, und ein Kontextobjekt, dessen Verhalten sich ändert, wenn sich sein Zustandsobjekt ändert. Zum Beispiel durchläuft ein Eiswürfel in der Hitze verschiedene Zustände(States) von hart, über flüssig bis hin zu verdampft. Ein Beispiel einer Applikation, wäre eine Photoshop-Tool Palette. Der Mauszeiger ändert sich, je nach ausgewähltem Tool (Pipette, Farbeimer, Pinsel).

          </p>
          <div class="img-wrapper">
            <img class="design-pattern" src="../images/statepattern.png ">
          </div>
        </div>

        <div class="accordion-item">
          <h3 class="accordion-title"> Iterator Pattern </h3>
          <p class="accordion-answer">
           
            Dieses Muster wird verwendet, um sequenziell auf die Elemente eines Sammlungsobjekts zuzugreifen, ohne die zugrunde liegende Darstellung kennen zu müssen. Wenn wir auf eine Sammlung von Objekten zugreifen möchten, ohne deren interne Darstellung offenzulegen. Wenn mehrere Durchläufe von Objekten in der Sammlung unterstützt werden müssen.<br>
            Zum Beispiel, wenn man im Webbrowser auf "zurück" geht, um den Verlauf aufzurufen.
          </p>
          <div class="img-wrapper">
            <img class="design-pattern" src="../images/iteratorpattern.png ">
          </div>
        </div>

        <div class="accordion-item">
          <h3 class="accordion-title"> Strategy Pattern </h3>
          <p class="accordion-answer">
           
            Im Strategy Pattern erstellen wir Objekte, die verschiedene Strategien darstellen, und ein Kontextobjekt, dessen Verhalten je nach Strategieobjekt variiert. Das Strategieobjekt ändert den Ausführungsalgorithmus des Kontextobjekts.

            Ein Strategy Pattern definiert eine Familie von Funktionalitäten,  umschließt jede einzelne davon und macht sie austauschbar.
            Es wird verwendet, wenn wir verschiedene Variationen eines Algorithmus benötigen.
            Zum Beispiel, wenn ein User Bilder(jpg, png, ...) hochlädt und diese dann filtert(contrast, black&white...)

            Der Unterschied zum State Pattern ist, dass wir keinen Single State haben sondern unterschiedliche Strategien verwenden.
          </p>
          <div class="img-wrapper">
            <img class="design-pattern" src="../images/strategypattern.png ">
          </div>
        </div>

        <div class="accordion-item">
          <h3 class="accordion-title"> Template Method Pattern </h3>
          <p class="accordion-answer">
            Die sogenannte "Schablonenmethode" ruft abstrakte Methoden auf, die erst in den Unterklassen definiert werden. Diese Methoden werden auch als Einschubmethoden bezeichnet. Dadurch besteht die Möglichkeit, einzelne Schritte des Algorithmus zu verändern oder zu überschreiben, ohne dass die zu Grunde liegende Struktur des Algorithmus modifiziert werden muss.<br><br> Zum Beispiel bei einer Buchungskontrolle(Audit-Trail) in einer Banking-App. Wir definieren in der abstrakten Klasse die Methode execute(){ audit.Trail.record();<br>
            doExecute();<br> und modifizieren über konkrete Klassen(TransferMoney, GenerateReport) die Ausführungen, in der die Buchungskontrolle stattfinden soll.
          </p>
 <div class="img-wrapper">
          <img class="design-pattern" src="../images/templatemethodpattern.png ">
        </div>
      </div>

        <div class="accordion-item">
          <h3 class="accordion-title"> Command Pattern </h3>
          <p class="accordion-answer">

            Mit dem Command Pattern können wir die "Seperation of Concerns" erzwingen, indem wir jede Aufgabe in eine eigene Klasse abstrahieren. Ein Vorteil dieses Entwurfsmusters besteht darin, dass es einfacher ist, neue Versionen von Aufgaben zu erstellen, z. B. Schaltflächen in einem Graphical User Interface Framework, die verschiedene Aktionen in ihren individuellen Applikationen ausführen sollen. Das Command Pattern stellt die objektorientierte Entsprechung zu Rückruffunktionen (callback functions) dar. Unser GUI-Framework soll für alle App-Entwickler funktionieren. Wir nutzen dieses Pattern, um den Sender vom Empfänger zu entkoppeln.
          </p>
 <div class="img-wrapper">
          <img class="design-pattern" src="../images/commandpattern.png ">
        </div>
      </div>

      
     

      <div class="accordion-item">
        <h3 class="accordion-title"> Undoable Command </h3>
        <p class="accordion-answer">

          Es gibt Kommandos, die rückgängig gemacht werden können (Schrift: bold) und andere, die nicht rückgängig gemacht werden können (Zoom-in). Deshalb bietet es sich an zwei Interfaces einzuführen. Mit dem Undoable Command Pattern können wir dies tun.
        </p>
<div class="img-wrapper">
        <img class="design-pattern" src="../images/undoablecommand.png ">
      </div>
    </div>

        <div class="accordion-item">
          <h3 class="accordion-title"> Observer Pattern </h3>
          <p class="accordion-answer">
           
            Das Observer Pattern(Beobachter) ist ein Entwurfsmuster, bei dem ein Objekt(Subjekt) eine Liste seiner abhängigen Objekte (Observer) verwaltet und sie automatisch über alle Zustandsänderungen benachrichtigt, normalerweise durch Aufrufen einer ihrer Methoden. Wir nutzen es, wenn sich der Status eines Objektes ändert und wir anderen Objekten dazu Bescheid geben müssen. Zum Beispiel in einer Excel mit mehreren Reitern(Werte, Summe) und einem Diagramm. Wenn sich die Werte ändern, muss sowohl die Summe als auch das Diagramm verändert werden. Innerhalb des Observer Patterns gibt es verschiedene Styles (push & pull).
          </p>
 <div class="img-wrapper">
          <img class="design-pattern" src="../images/observerpattern.png ">
        </div>
      </div>


      <div class="accordion-item">
        <h3 class="accordion-title"> Mediator Pattern </h3>
        <p class="accordion-answer">
         
          Dieses Pattern wird verwendet, um die Kommunikationskomplexität zwischen mehreren Objekten zu reduzieren. Anstatt innerhalb jeder Klasse die direkte Kommunikation mit anderen Klassen (starkes Coupling) zu implementieren, wird ein Mediator-Objekt eingesetzt und jede Klasse kann dieses Mediator-Objekt aufrufen, um mit anderen zu kommunizieren. Dies kann das Coupling zwischen den Klassen lockern und die Entwicklung und Erweiterung des Programms erleichtern.

        </p>
 <div class="img-wrapper">
          <img class="design-pattern" src="../images/mediatorpattern.png ">
        </div>
      </div>

      <div class="accordion-item">
        <h3 class="accordion-title"> Chain of Responsibility Pattern </h3>
        <p class="accordion-answer">
         
          Um zu vermeiden den Sender einer Anfrage an den Empfänger zu koppeln, geben wir mehr als einem Objekt die Möglichkeit, die Anfrage zu bearbeiten. Diese Objekte verketten wir, um die Anforderung entlang der Kette zu übergeben, bis ein Objekt sie verarbeitet.

          Wenn wir zum Beispiel einen HTTP-Request über einen Webserver vornehmen und eine Pipeline/Kette an Objekten benötigen, um unsere Anfrage zu prozessuieren. Wenn Authentifizierung erfolgreich, wird der Request weitergeben und wenn nicht, dann nicht.
        </p>
 <div class="img-wrapper">
          <img class="design-pattern" src="../images/chainpattern.png ">
        </div>
      </div>
      
      <div class="accordion-item">
        <h3 class="accordion-title"> Visitor Pattern </h3>
        <p class="accordion-answer">
         
          
          Oft ist es schwierig, nicht miteinander verwandte Operationen in die Klassen einer Objektstruktur zu integrieren. Bei der Erweiterung um neue Operationen müssen alle Klassen erweitert werden. Das Visitor-Pattern lagert die Operationen in externe Besucherklassen aus. Dazu müssen die zu besuchenden Klassen eine Schnittstelle zum Empfang eines Besuchers definieren.
          <br><br>
          Das Pattern ermöglicht das Hinzufügen neuer Funktionen, ohne vorhandene Klassen zu ändern. Es bietet eine Möglichkeit, einen Algorithmus einfach von einer Objektstruktur zu trennen. 
          
        </p>
        <div class="img-wrapper">
          <img class="design-pattern" src="../images/visitorpattern.png ">
        </div>
      </div>


    </div>
          <section>
        <header>
          <hr />
          <hr />
          <h3>/////////////Structural Design Patterns/////////////</h3>
          <p>Hier geht es um die Beziehungen zwischen Objekten</p>
         
        </header>
      </section>

      <div class="accordion">
        <div class="accordion-item">
          <h3 class="accordion-title"> Composite Pattern </h3>
          <p class="accordion-answer">
  
            Das Composite Command beschreibt eine Gruppe von Objekten, die genauso behandelt werden wie eine einzelne Instanz desselben Objekttyps. 
  
            Mit dem Composite Command Pattern können wir bspw. eine "Save All"-Funktion in einer Applikation für mehrere Tabs  einbringen, um zu ermöglichen, dass nicht jedes Tab einzeln gespeichert werden muss. Ein anderes Beispiel wäre eine Hiearchie in Objekten z.B. in Powerpoint. Wir können Formen gruppieren und sie dann gleichzeitig bewegen, vergrößern usw.
          </p>
  <div class="img-wrapper">
          <img class="design-pattern" src="../images/compositepattern.png ">
        </div>
      </div>

        <div class="accordion-item">
          <h3 class="accordion-title"> Adapter Pattern </h3>
          <p class="accordion-answer">
            Ein Adapter-Pattern fungiert als Verbindung zwischen zwei inkompatiblen Schnittstellen, die ansonsten nicht direkt verbunden werden können. Ein Adapter umschließt eine vorhandene Klasse mit einer neuen Schnittstelle, damit sie mit der Schnittstelle des Clients kompatibel wird.
            <br><br>
              Dieses Pattern wird verwendet, um bspw. ein Interface einer Klasse zu einer anderen Form zu konvertieren. Zum Beispiel, um ein Foto mit Filtern zu versehen. Hinweis: In Java ist eine Composition flexibler, denn in Java gibt es keine multiple Vererbung.
          </p>
          <div class="img-wrapper">
            <img class="design-pattern" src="../images/adapterpattern.png ">
          </div>
        </div>
          
        <div class="accordion-item">
          <h3 class="accordion-title"> Decorator Pattern </h3>
          <p class="accordion-answer">
           
            Das Decorator Pattern ist oft nützlich, um das Prinzip der Single Responsibility einzuhalten, da es die Aufteilung der Funktionalität auf Klassen mit eindeutigen Problembereichen ermöglicht. Die Verwendung von Decorator kann effizienter sein als die Unterklassenbildung, da das Verhalten eines Objekts verbessert werden kann, ohne ein völlig neues Objekt zu definieren. Es wird bspw. verwenden, wenn eine "Stream"-Klasse erweitert werden soll, die eigentlich nur Daten in die Cloud hochlädt. In einigen Fällen sollen aber Daten encrypted werden und dazu verhilft uns das Decorator Entwurfsmuster.
             
          </p>
          <div class="img-wrapper">
            <img class="design-pattern" src="../images/decoratorpattern.png ">
          </div>
        </div>

        <div class="accordion-item">
          <h3 class="accordion-title"> Facade Pattern </h3>
          <p class="accordion-answer">
           
            "Provide a simple interface to a complex system" - Das Fassadenmuster wird häufig verwendet, wenn eine Interaktion mit einer komplexen externen Bibliothek oder einem Dienst stattfindet. Es wird genutzt, um coupling zu reduzieren.

            In diesem Muster erstellen wir eine Klasse, um die Interaktionen mit der Third-Party-Library zu kapseln. Diese Klasse wird Fascade (Fassade) genannt. Dies ermöglicht es uns, dem Rest unserer Anwendung eine einfachere Schnittstelle bereitzustellen. Entwickler, die an anderen Teilen unseres Systems arbeiten, müssen die Bibliothek von Drittanbietern nicht lernen; Stattdessen müssen sie nur mit der von uns erstellten Fassadenklasse verbunden werden. Zum Beispiel bei einer mobilen App - "Send push-notifications to Users".
          </p>
 <div class="img-wrapper">
          <img class="design-pattern" src="../images/facadepattern.png ">
        </div>
      </div>

        <div class="accordion-item">
          <h3 class="accordion-title"> Flyweight Pattern </h3>
          <p class="accordion-answer">
           
            Das Flyweight Pattern(Fliegengewicht) ist eine bewährte, wiederverwendbare Vorlage, sie dient als eine Art Lösungsschablone.
            Das Entwurfsmuster wird häufig verwendet, wenn wir ähnliche Daten für mehrere Objekte gruppieren möchten. Der Hauptzweck besteht darin, gemeinsame Daten für mehrere Objekte an einem einzigen Ort zu speichern und somit die Speichernutzung zu optimieren. Zum Beispiel bei GoogleMaps. Wenn wir zuviel Memory-Space für die Icons der Ortungs-Points verwenden, würde die App crashen. Deshalb bedient man sich dem Flyweight Pattern, das die Daten für die verschiedenen Points aus einer Schablone zieht.
 
          </p>
 <div class="img-wrapper">
          <img class="design-pattern" src="../images/flyweightpattern.png ">
        </div>
      </div>

        <div class="accordion-item">
          <h3 class="accordion-title"> Bridge Pattern </h3>
          <p class="accordion-answer">
           
            Das Bridge Pattern hilft uns, wenn wir verschiedene Datenbanktreiber für unseren Repository verwenden müssen. Um die Verwendung separater Repositorys oder Klassen für verschiedene Datenbanktreiber zu vermeiden, ist das Bridge-Designmuster ein  eleganter Weg. Mit dem Bridge Pattern können wir flexible Hiearchien bilden, die unabhängig voneinander wachsen können. Beispielsweise bei einer Universellen Fernbedienung: Um zu vermeiden, dass wir für jede TV-Marke eine eigene Klasse/Repository bilden müssen, kann das Pattern die Brücke zwischen Feature und Implementation bilden und zwei separate Hierarchien zusammenbringen.

          </p>
 <div class="img-wrapper">
          <img class="design-pattern" src="../images/bridgepattern.png ">
        </div>
      </div>

        <div class="accordion-item">
          <h3 class="accordion-title"> Proxy Pattern </h3>
          <p class="accordion-answer">
           
            Das Proxy Pattern bietet einen Ersatz/ Platzhalter für ein anderes Objekt, um den Zugriff darauf zu steuern. Wir können dieses Muster verwenden, um ein darstellbares Objekt zu erstellen, das den Zugriff auf ein anderes Objekt steuert, das möglicherweise weit entfernt, teuer zu erstellen/ zu sichern ist. Zum Beispiel bei einer EBook-App mit integrierter Bibliothek all unserer Bücher. Wir wollen aber nur eins davon laden und nicht alle gleichzeitig. Um das Ebook nur zu laden, wenn wir es brauchen, initializieren wir das "private field" realEbook absichtlich nicht.

          </p>
 <div class="img-wrapper">
          <img class="design-pattern" src="../images/proxypattern.png ">
        </div>
      </div>

      </div>
      
      <section>
        <header>
          <hr />
          <hr />
          <h3>/////////////Creational Design Patterns/////////////</h3>
          <p>Hier geht es um die verschiedenen Wege, um Objekte zu kreiieren</p>
        </header>
      </section>

      <div class="accordion">
        <div class="accordion-item">
          <h3 class="accordion-title"> Prototype Pattern </h3>
          <p class="accordion-answer">
           
            Im Prototype Pattern werden neue Instanzen auf Grundlage von prototypischen Instanzen („Vorlagen“) erzeugt. Dabei wird die Vorlage kopiert und an neue Bedürfnisse angepasst. Wenn wir beispielsweise eine Form (z.B. einen Kreis) in Powerpoint kopieren wollen. 
          </p>
          <div class="img-wrapper">
          <img class="design-pattern" src="../images/prototypepattern.png ">
        </div>
      </div>

        <div class="accordion-item">
          <h3 class="accordion-title"> Singleton Pattern </h3>
          <p class="accordion-answer">
           
            Ein Singleton bedeutet (wie "single" schon sagt) die Beschränkung der Instanziierung einer Klasse auf eine einzelne Instanz.Mit anderen Worten, jedes Mal, wenn wir die Klasse verwenden, ist es jedoch dasselbe Objekt, das wir zuerst erstellt haben. 
            
            Dieses Muster ermöglicht es uns also, von jeder Datei oder Funktion aus auf die Member einer Klasseninstanz zuzugreifen und sie zu bearbeiten. Diese Singletons können Schnittstellen implementieren, Methoden als Argumente übergeben und können polymorph sein.          
      
            Einsatzbeispiel: Eine Klasse, die unsere Konfigurationseinstellungen der Applikation managed.

          </p>
        <div class="img-wrapper">
          <img class="design-pattern" src="../images/singletonpattern.png ">
        </div>
      </div>

        <div class="accordion-item">
          <h3 class="accordion-title"> Factory Method Pattern </h3>
          <p class="accordion-answer">
            Das Fabrikmethodenmuster ist eine clevere, aber subtile Erweiterung des Konzepts, dass eine Klasse als eine Art "Verkehrspolizist" fungiert und entscheidet, welche Unterklasse einer einzelnen Hierarchie instanziiert wird.
            
            Im Factory-Pattern erstellen wir ein Objekt, ohne die Erstellungslogik offenzulegen. Eine Schnittstelle wird zum Erstellen eines Objekts verwendet, lässt jedoch die Unterklasse entscheiden, welche Klasse instanziiert werden soll. Anstatt jedes Objekt manuell zu definieren, können wir dies programmgesteuert tun.
          
            Kurz gesagt, eine Fabrik ist ein Objekt, das Objekte ohne die Verwendung eines Konstruktors erstellt.
          </p>
        <div class="img-wrapper">
          <img class="design-pattern" src="../images/factorymethodpattern.png ">
        </div>
      </div>

        <div class="accordion-item">
          <h3 class="accordion-title"> Abstract Factory Pattern </h3>
          <p class="accordion-answer">
            Das Abstract Factory Pattern stellt eine Schnittstelle zum Erstellen von Klassenfamilien ohne konkrete Implementierungen bereit.
           
            Stellen wir uns vor, wir erstellen ein Shopsystem für ein Möbelhaus. Der Laden verkauft Stühle, Sofas, etc...
            
            Doch es gibt nicht nur einen Stuhltyp, sondern mehrere Stuhltypen.
            Diese Stuhltypen könnte man auch eine Stuhlfamilie nennen, daher gibt es für jeden Stuhltyp unterschiedliche Klassen.
            Allerdings muss er auch zu den Möbelstücken ähnlicher Stile zusammengebracht werden können (z.B. Landhaus)
            
            Das abstract Factory Pattern verwenden wir, wenn unser Code mit verschiedenen Familien verwandter Produkte arbeiten muss, aber nicht von den konkreten Klassen dieser Produkte abhängig sein soll.
            Achtung: Der Code kann komplizierter werden, als er sein sollte, da mit diesem Muster viele neue Schnittstellen und Klassen eingeführt werden.
          </p>
          <div class="img-wrapper">
          <img class="design-pattern" src="../images/abstractfactorypattern.png ">
        </div>
      </div>

        <div class="accordion-item">
          <h3 class="accordion-title"> Builder Pattern </h3>
          <p class="accordion-answer">
           
            Das Builder-Muster wurde eingeführt, um einige der Probleme mit Factory- und Abstract Factory-Entwurfsmustern zu lösen (z.B. wenn das Objekt sehr viele Attribute enthält).Es wird meistens verwendet, wenn ein Objekt nicht in einem Schritt erstellt werden kann.
            
            Das Builder Pattern konstruiert ein komplexes Objekt aus einfachen Objekten mithilfe eines Schritt-für-Schritt-Ansatz.
            Eine Builder-Klasse erstellt in dem Sinne  schrittweise das endgültige Objekt. Dieser Builder ist unabhängig von anderen Objekten.          
          </p>
        <div class="img-wrapper">
          <img class="design-pattern" src="../images/builderpattern.png ">
        </div>
      </div>

      </div>
    </div>


    <!-- https://dev.to/fahimulhaq/the-7-most-important-software-design-patterns-2fea -->


        <footer class="major container medium videoWrapper" >     
          <h3>Design Patterns - Rezepte für Lösungen</h3> 
          <img src="../images/designrecepies.gif"/ >
         </footer>
        </div> 

    <!-- Footer -->
    <div id="footer">
      <div class="container medium">
        <header class="major last">
          <h2>Questions or comments?</h2>
        </header>

        <p>
          Einfach eine <a href="https://www.ninabraunger.de/#contact">Mail</a> schreiben.<br />
        </p>

        <ul class="copyright">
          <li>&copy; 2021 Nina Braunger</li>
          <li>
            <a href="https://www.ninabraunger.de/impressum.html">Impressum</a>
          </li>
          <li>
            <a href="https://www.ninabraunger.de/datenschutz.html"
              >Datenschutz</a
            >
          </li>
          <li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
          <br />
          <br />
          <li>
            Structure of site is released for free under the
            <a href="http://html5up.net/license">Creative Commons license</a>.
          </li>
        </ul>
      </div>
    </div>

    <!-- Scripts -->
    <script src="../assets/js/jquery.min.js"></script>
    <script src="../assets/js/browser.min.js"></script>
    <script src="../assets/js/breakpoints.min.js"></script>
    <script src="../assets/js/util.js"></script>
    <script src="../assets/js/main.js"></script>
  </body>
</html>
